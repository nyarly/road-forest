RDFa + HTML support:
  Templates that recognize affordance vocab

  Implement the POST RDF representation per
  http://www.lsrn.org/semweb/rdfpost.html
    Remember that RDFa + FORM children: the object of triples from RDFa are
    either @content or the text children of the appropriate element - <input
    text /> is a single element - it cannot have children, and the @value
    doesn't play with RDFa, so will need to (naively) copy the @value to
    @content - implies a "human form" filter to map the @content to @value

  Test helpers: this graph is represented in this RDFa response

  Valise based template searching

  Generic "helper" Resources -
    POST thing/:id/delete => DELETE thing/:id
    POST thing/:id/put => PUT thing/:id
      Might need to convert mime type as well.
    POST blob/:id/put [mime-multipart...] => PUT blob/:id [<embedded mime]


Final cleanup of files, classes interface
  Big question: Is "Model" the right name for that class?

***=== Current Target ===***

Performance
  Currently it take 8 seconds to run spec/client.rb - where does that time go?
  RDF smashing the method cache, or somewhere else?

Define RDF affordance vocab
  Have reviewed rdforms, RDF Forms, Hydra, and draft RDF Affordances vocab. Not
  thrilled with any of them. Hydra might provide almost everything I want, but
  there's extra things I'd rather leave out. Something like woud be required to
  complete the REST requirements. (q.v. Amundsen: RESTful Web APIs).

  Missing link is an authorization affordance: akin to the keyhole next to the
  knob on a door.

Client interaction with affordance vocab
  e.g. a resource that's the target of a NullAffordance should not be derefed.



Add support for Expect: 100-continue
  In the presence of a large body, UserAgent should add an Expect: 100-continue
  header. Server should reply 100 if endpoint exists (+ other conditions? Model
  concern.) Response code of 100 retries w/o the Expect header.

  Implication probably is that UserAgent should have a method for making
  requests that accepts "prior request, prior response" and loop over that.

  Or even that there's a ClientTransaction with a string of requests and
  responses.

Oauth2 support
  A set of Oauth2 provider resources
  An OA2 consumer for authn

Authorization Affordance
  Single property of affordances:
    <#affordance> aa:authorized_by <#zToken resource>
  GET on #zToken -> 401 unless you have it.
  Resource (qparm for user or ...) with list of zTokens.
    Search affordance for same in 401 responses

Cross model interactions:
  PUT/POST to create by generating ids and back-ending request to the other
  model - requires Param manipulation

Ruby HTTP client that respects cache
  Options:
    Extend existing Excon adapter with home-brewed cacheing
    Switch to: (?)
      wrest
      typhoeus
      rufus-verbs

Focus Rigor switching:
  API for a GraphFocus to change the rigor it's using

"Strict" vocabularies:
  Vocab classes that have an RDFS document (in addition to their prefix and
  URL), from which they can load properties and classes, but also the human
  descriptions etc.
  Tools to pull the document from it's source.
  Tools to help edit new RDFS?
  Integration with RDFa templates

Pagination:
  A pagination vocab:
    the rdf:List of items on this page - last item goes to next page
    the IRI of the subject that links here
    the page:SkipList of pages
    the page:totalcount of list items ...
  Backend tools to build cacheable pages - including overlapping first page,
  and pages that know to go to "cache forever"

Client error exceptions
  40x -> per code exception classes, include Response content

Inference investigator
  Look for statements that could be used to infer a response to current pattern
  Insert inferred statements
  Relies on RDFS/OWL

Other concerns:
  Authentication
  Authorization
  Content encoding (gzip, compress)
  Charsets
  Languages
  Exception handling

HTML related:
  Form rendering

Cacheing - last_modified, expires
  Cache-control headers (WM PR)

property delete

property replace

repo autovacuum

BGP queries should be solveable *across* resources - currently all patterns get
a :context variable applied that all have to match, but it seems reasonable
that multiple resources might participate in a solution. - might now work:
needs tests

HTTP behaviors:
Handling status codes -
  Empty vs. full responses (200 v 204)
  3xx and Location following
  4xx - sometimes correctable, otherwise...
  5xx

Strict Vocabularies: use the Vocab URL to pull the RDFS (or OWL?) description
of the vocab and define properties in the vocab that way. Also, use human
descriptions for fields in RDFa, for instance.

Error Handling
  Specifically, when the server returns 500, a RemoteHost#<act>ing starts
  returning nils - which is super confusing. On the other hand, it's not
  completely clear how to handle server errors yet (or any HTTP error...) Maybe
  collect them, and in the course of anything annealed, enrich exceptions with
  a notice that "There are 3 500 errors - access them with
  RemoteHost#current_errors" or something.

  When a representation doesn't contain statements about the requested
  resource, that's an error that should be reported. (Excon adds a / to empty
  paths...)

*** API challenges ***

Client behavior should get packed up in a tidy bunch of chains and blocks, but
if there's an error, Ruby's default exceptions aren't helpful.  NullObjects of
some kind?

Remove the _:local context - it doesn't make sense on the GM. Writes to a GM
should come from 3 places:

 * A GraphFocus, that has an implicit context to write to.
 * Raw #insert by client code - in which case, vaya con Dios
 * #insert_document, which has an explicit context to write to.

GM's should also accept non-ResourceQuery|Patterns. Simple to RQ|P.from(q|p),
with infered contexts.

Infered contexts raises this interesting point: every pattern potentially has 6
contexts to consider as credible:

 * Its context
 * Its subject
 * Its object
 * Contexts mentioned in its query
 * Subjects mentioned in its query
 * Objects mentioned in its query

(Not every pattern will have all 6) (Also - more than one of any may result in
an empty result - a Query with two contexts I *think* means "statements must
have this context and that context" which is impossible.)

That said, these resources might then form the basis of a credence review


*** Pure Mad Science ***

Omniscient test server.

  Basically: RemoteHost collects the requests that get made and records them.
  Play against server, and then "flatten" resulting meta-graph. TestServer simply
  replies to everything with flattened graph - possibly changing state (graph) on
  PUT/POST/DELETE.

  Two sets of test files:

  client -> server requests, the responses of which can be tested and recorded

  server -> client responses, used as fixtures for client tests - right things
  displayed / correct POSTs made.

  Some things that happen: the client patterns are recorded along with something
  about their results - maybe as little as "empty?"

  The server responses are built into "states" related on an FSM. Transitions are
  a subset of the Requests - against every state, all the requests are replayed
  to see what changes - state transition "occurs" ... hm. Because what we get
  from a single request is always a subset... bears thinking on.

  Goal of the test tool is to split the testing of clients and servers. For
  servers to be able to evolve against a set of actual client expectations, and
  for clients to be able to test against real server replies without needing to
  start a server.

Wire Transfer
  This amounts to "replace HTTP" - REST and HTTP aren't identical. Considering
  Protobufs (or similar), but also "in process" - where the transfer is a null
  operation: here's the graph I made for you.


Single Graph Update
 -- reflection indicates this should be removed. It's not really RESTful, and
 the use case (the converse of front loading) actually doesn't seem to make
 sense. "Batch" or "transaction" updates really should be collected into a new
 resource, if it makes sense. If it doesn't you probably don't really want that
 kind of update anyway


Statistical Front Loading
based on human definitions of resource graphs, and
emperical collection of client behavior (e.g. GET resourceB, Referer:
resourceA, (X-)Triggering-Property: propC), determine properties to front-load
into requests for resourceA to reduce the likelihood of subsequent request for
B. Contributing factors include the size of the extra data, impact on cacheing,
actual impact on subsequent requests (since propC shadows some non-negative
number of other properties we need about resourceB.)

Consider case of an list of users page - client wants names and roles for all
users. So UserList -> User1,User2,User3 etc because of foaf:name and also
authn:role. Once we front load both foaf:name and authn:name, UserList ->
User17, because that's the particular user we want. But: foaf:name makes not
impact by itself (except to change the triggering property), and both aren't an
absolute impact. On the other extreme, front-loading everything from User into
UserList probably stops requests for User17, but the network transfer is
greater as a result.

Certainly, there's a tendancy for everything to be front loaded, and as clients
change we might need to experimentally roll back a front-loading to see if that
triggers more requests.
